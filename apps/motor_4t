<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Visualizador Interactivo Motor 4 Tiempos</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00aaff;
            color: #00aaff;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.3);
            pointer-events: auto;
            z-index: 10;
        }
        #phase-indicator {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffffff;
            text-shadow: 0 0 10px #00aaff;
        }
        .control-group { margin-bottom: 10px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type=range] { width: 200px; accent-color: #00aaff; }
        #cycle-description {
            font-size: 14px; color: #ccc; margin-top: 5px; font-style: italic;
        }
    </style>
</head>
<body>

<div id="ui-container">
    <div id="phase-indicator">FASE: ESPERANDO...</div>
    <div id="cycle-description">El ciclo de Otto comienza.</div>
    <hr style="border-color: #004466;">
    <div class="control-group">
        <label for="speedSlider">Velocidad (RPM Estimadas)</label>
        <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1">
    </div>
    <p style="font-size: 12px;">Arrastra el ratón para rotar la cámara.<br>Rueda del ratón para zoom.</p>
</div>

<!-- Three.js core -->
<script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
<!-- OrbitControls (versión JS clásica, añade THREE.OrbitControls al global) -->
<script src="https://unpkg.com/three@0.150.1/examples/js/controls/OrbitControls.js"></script>

<script>
    // --- Configuración Escena ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510); // Fondo oscuro azulado
    scene.fog = new THREE.Fog(0x050510, 20, 100);

    const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.position.set(15, 15, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 5, 0);

    // --- Iluminación ---
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // Luz de la explosión (punto de luz dinámico)
    const explosionLight = new THREE.PointLight(0xff5500, 0, 50);
    explosionLight.position.set(0, 10, 0);
    scene.add(explosionLight);

    // --- Materiales Estéticos (Blueprint/Holográfico) ---
    const metalMaterial = new THREE.MeshStandardMaterial({
        color: 0xaaaaaa,
        metalness: 0.8,
        roughness: 0.2,
        emissive: 0x112233,
        emissiveIntensity: 0.2
    });

    const glassMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x88ccff,
        metalness: 0.1,
        roughness: 0.1,
        transmission: 0.9,
        opacity: 0.4,
        transparent: true,
        side: THREE.DoubleSide
    });

    const wireframeMaterial = new THREE.LineBasicMaterial({
        color: 0x00aaff,
        opacity: 0.3,
        transparent: true
    });

    // --- Construcción del Motor ---
    const motorGroup = new THREE.Group();
    scene.add(motorGroup);

    // 1. Cilindro (Transparente con bordes brillantes)
    const cylinderGeo = new THREE.CylinderGeometry(5, 5, 16, 32, 1, true);
    const cylinderMesh = new THREE.Mesh(cylinderGeo, glassMaterial);
    cylinderMesh.position.y = 8;
    motorGroup.add(cylinderMesh);

    // Bordes del cilindro
    const cylinderWireframe = new THREE.LineSegments(
        new THREE.EdgesGeometry(cylinderGeo),
        wireframeMaterial
    );
    cylinderWireframe.position.y = 8;
    motorGroup.add(cylinderWireframe);

    // 2. Pistón
    const pistonGeo = new THREE.CylinderGeometry(4.8, 4.8, 4, 32);
    const piston = new THREE.Mesh(pistonGeo, metalMaterial);
    motorGroup.add(piston);

    // 3. Cigüeñal (simplificado)
    const crankshaftCenter = new THREE.Group();
    crankshaftCenter.position.y = -4;
    motorGroup.add(crankshaftCenter);

    const crankArmGeo = new THREE.BoxGeometry(2, 6, 1);
    const crankArm = new THREE.Mesh(crankArmGeo, metalMaterial);
    crankArm.position.y = 3;
    crankshaftCenter.add(crankArm);

    const counterWeight = new THREE.Mesh(
        new THREE.CylinderGeometry(4, 4, 2, 16),
        metalMaterial
    );
    counterWeight.rotation.x = Math.PI / 2;
    counterWeight.position.y = -1;
    crankshaftCenter.add(counterWeight);

    // 4. Biela
    const rodGeo = new THREE.BoxGeometry(1, 12, 1);
    const rod = new THREE.Mesh(rodGeo, metalMaterial);
    motorGroup.add(rod);

    // 5. Válvulas y Bujía (Culata)
    const headGeo = new THREE.CylinderGeometry(6, 5, 2, 32);
    const head = new THREE.Mesh(headGeo, metalMaterial);
    head.position.y = 17;
    motorGroup.add(head);

    // Válvula de Admisión (Izquierda)
    const intakeValve = new THREE.Group();
    intakeValve.position.set(-2.5, 16.5, 0);
    const valveStemGeo = new THREE.CylinderGeometry(0.3, 0.3, 4);
    const valvePlateGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.5);
    const iStem = new THREE.Mesh(valveStemGeo, metalMaterial);
    const iPlate = new THREE.Mesh(valvePlateGeo, metalMaterial);
    iPlate.position.y = -2;
    intakeValve.add(iStem);
    intakeValve.add(iPlate);
    motorGroup.add(intakeValve);

    // Válvula de Escape (Derecha)
    const exhaustValve = new THREE.Group();
    exhaustValve.position.set(2.5, 16.5, 0);
    const eStem = new THREE.Mesh(valveStemGeo, metalMaterial);
    const ePlate = new THREE.Mesh(valvePlateGeo, metalMaterial);
    ePlate.position.y = -2;
    exhaustValve.add(eStem);
    exhaustValve.add(ePlate);
    motorGroup.add(exhaustValve);

    // Bujía (Centro)
    const sparkPlugGeo = new THREE.ConeGeometry(0.5, 2, 16);
    const sparkPlug = new THREE.Mesh(
        sparkPlugGeo,
        new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: 0x555555
        })
    );
    sparkPlug.position.set(0, 17, 0);
    sparkPlug.rotation.x = Math.PI;
    motorGroup.add(sparkPlug);

    // --- Sistema de Partículas (Gasolina y Humo) ---
    function createParticleSystem(color, count, size) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            // Ocultar inicialmente
            positions[i * 3] = 0;
            positions[i * 3 + 1] = -100;
            positions[i * 3 + 2] = 0;
        }
        geometry.setAttribute(
            "position",
            new THREE.BufferAttribute(positions, 3)
        );
        const material = new THREE.PointsMaterial({
            color: color,
            size: size,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        return new THREE.Points(geometry, material);
    }

    const intakeParticles = createParticleSystem(0x0088ff, 200, 0.8);  // Azul mezcla
    motorGroup.add(intakeParticles);

    const exhaustParticles = createParticleSystem(0x888888, 200, 1.2); // Gris humo
    motorGroup.add(exhaustParticles);

    const explosionParticles = createParticleSystem(0xffaa00, 100, 2.0); // Fuego
    motorGroup.add(explosionParticles);

    // --- Variables de Simulación ---
    let crankAngle = 0;
    const crankRadius = 4;
    const rodLength = 12;
    let speed = 1; // Velocidad base

    // Referencias UI
    const speedSlider = document.getElementById("speedSlider");
    const phaseIndicator = document.getElementById("phase-indicator");
    const cycleDescription = document.getElementById("cycle-description");

    speedSlider.addEventListener("input", (e) => {
        speed = parseFloat(e.target.value);
    });

    // --- Bucle de Animación Principal ---
    function animate() {
        requestAnimationFrame(animate);

        // Actualizar ángulo (Ciclo completo es 720 grados o 4*PI radianes)
        crankAngle += speed * 0.05;
        const cycleAngleDeg = (crankAngle * (180 / Math.PI)) % 720;

        // 1. Movimiento Mecánico
        // Rotar cigüeñal
        crankshaftCenter.rotation.z = crankAngle;

        // Posición del cigüeñal
        const crankY = crankRadius * Math.cos(crankAngle);
        const crankX = crankRadius * Math.sin(crankAngle);

        // Posición Y del bulón del pistón (cinemática)
        const crankPivotY = crankshaftCenter.position.y + crankY;
        const pistonPinY =
            crankPivotY + Math.sqrt(rodLength * rodLength - crankX * crankX);

        piston.position.y = pistonPinY;

        // Posicionar y rotar la biela
        rod.position.set(
            crankX / 2,
            (pistonPinY + crankPivotY) / 2,
            0
        );
        const rodAngle = Math.atan2(crankX, pistonPinY - crankPivotY);
        rod.rotation.z = -rodAngle;

        // 2. Lógica de los 4 Tiempos y Efectos
        let currentPhase = "";
        let descText = "";
        let intakeOpen = false;
        let exhaustOpen = false;
        explosionLight.intensity = 0; // Reset luz explosión

        // Reset partículas: mover fuera de vista
        [intakeParticles, exhaustParticles, explosionParticles].forEach(sys => {
            const positions = sys.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] = 0;
                positions[i + 1] = -100;
                positions[i + 2] = 0;
            }
            sys.geometry.attributes.position.needsUpdate = true;
        });

        if (cycleAngleDeg >= 0 && cycleAngleDeg < 180) {
            // --- FASE 1: ADMISIÓN (Bajando) ---
            currentPhase = "1. ADMISIÓN";
            descText = "El pistón baja, la válvula de admisión se abre. Entra mezcla aire/combustible.";
            intakeOpen = true;

            // Animación Partículas Admisión
            const positions = intakeParticles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length / 3; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 4 + -2.5; // X bajo admisión
                positions[i * 3 + 1] = 16 - Math.random() * (16 - piston.position.y); // Y
                positions[i * 3 + 2] = (Math.random() - 0.5) * 4; // Z
            }
            intakeParticles.geometry.attributes.position.needsUpdate = true;

        } else if (cycleAngleDeg >= 180 && cycleAngleDeg < 360) {
            // --- FASE 2: COMPRESIÓN (Subiendo) ---
            currentPhase = "2. COMPRESIÓN";
            descText = "Ambas válvulas cerradas. El pistón sube comprimiendo la mezcla.";

        } else if (cycleAngleDeg >= 360 && cycleAngleDeg < 540) {
            // --- FASE 3: EXPLOSIÓN / COMBUSTIÓN (Bajando) ---
            currentPhase = "3. EXPLOSIÓN";
            descText = "¡CHISPA! La mezcla explota empujando el pistón hacia abajo con fuerza.";

            // Efecto de chispa justo al inicio (aprox 360-375 grados)
            if (cycleAngleDeg < 375) {
                explosionLight.intensity = 15; // Flash de luz

                const positions = explosionParticles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 8;
                    positions[i * 3 + 1] = 15 - Math.random() * 2;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 8;
                }
                explosionParticles.geometry.attributes.position.needsUpdate = true;
            }

        } else {
            // --- FASE 4: ESCAPE (Subiendo) ---
            currentPhase = "4. ESCAPE";
            descText = "El pistón sube, la válvula de escape se abre para expulsar los gases quemados.";
            exhaustOpen = true;

            // Animación Partículas Escape
            const positions = exhaustParticles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length / 3; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 4 + 2.5; // X bajo escape
                positions[i * 3 + 1] =
                    piston.position.y + Math.random() * (16 - piston.position.y);
                positions[i * 3 + 2] = (Math.random() - 0.5) * 4;
            }
            exhaustParticles.geometry.attributes.position.needsUpdate = true;
        }

        // Animación de Válvulas (simple up/down)
        intakeValve.position.y = THREE.MathUtils.lerp(
            intakeValve.position.y,
            intakeOpen ? 15.5 : 16.5,
            0.2
        );
        exhaustValve.position.y = THREE.MathUtils.lerp(
            exhaustValve.position.y,
            exhaustOpen ? 15.5 : 16.5,
            0.2
        );

        // Actualizar UI
        phaseIndicator.innerText = currentPhase;
        cycleDescription.innerText = descText;

        controls.update();
        renderer.render(scene, camera);
    }

    // Manejo de redimensionado de ventana
    window.addEventListener("resize", onWindowResize, false);
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Iniciar animación
    animate();
</script>
</body>
</html>
